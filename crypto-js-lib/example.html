<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crypto JS Library - ä½¿ç”¨ç¯„ä¾‹</title>
  <script type="importmap">
    {
      "imports": {
        "hash-wasm": "https://cdn.jsdelivr.net/npm/hash-wasm@4.11.0/dist/index.esm.min.js"
      }
    }
  </script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 10px;
      padding: 30px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
    }
    h1 {
      color: #333;
      margin-bottom: 10px;
      text-align: center;
    }
    .subtitle {
      text-align: center;
      color: #666;
      margin-bottom: 30px;
    }
    .section {
      margin-bottom: 40px;
      padding: 20px;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      background: #f9f9f9;
    }
    .section h2 {
      color: #667eea;
      margin-bottom: 15px;
      border-bottom: 2px solid #667eea;
      padding-bottom: 10px;
    }
    .input-group {
      margin-bottom: 15px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      color: #555;
      font-weight: bold;
    }
    input, textarea {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-size: 14px;
      font-family: monospace;
    }
    textarea {
      min-height: 80px;
      resize: vertical;
    }
    button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      font-weight: bold;
      margin-right: 10px;
      margin-bottom: 10px;
      transition: transform 0.2s;
    }
    button:hover {
      transform: translateY(-2px);
    }
    button:active {
      transform: translateY(0);
    }
    .result {
      margin-top: 15px;
      padding: 15px;
      background: white;
      border-radius: 5px;
      border-left: 4px solid #667eea;
      word-break: break-all;
    }
    .result strong {
      color: #667eea;
    }
    .error {
      border-left-color: #e74c3c;
      color: #e74c3c;
    }
    .success {
      border-left-color: #27ae60;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ” Crypto JS Library</h1>
    <p class="subtitle">å®Œæ•´çš„å‰ç«¯åŠ å¯†å‡½å¼åº«ä½¿ç”¨ç¯„ä¾‹</p>

    <!-- AES åŠ å¯† -->
    <div class="section">
      <h2>1. AES åŠ å¯† (å°ç¨±åŠ å¯†)</h2>
      <div class="input-group">
        <label>æ˜æ–‡:</label>
        <input type="text" id="aesPlainText" value="Hello, é€™æ˜¯æ¸¬è©¦è¨Šæ¯!" placeholder="è¼¸å…¥è¦åŠ å¯†çš„æ–‡å­—">
      </div>
      <div class="input-group">
        <label>å¯†é‘°:</label>
        <input type="text" id="aesKey" value="mySecretKey123" placeholder="è¼¸å…¥å¯†é‘°">
      </div>
      <button onclick="aesEncryptFixed()">åŠ å¯† (å›ºå®š IV)</button>
      <button onclick="aesEncryptRandom()">åŠ å¯† (éš¨æ©Ÿ IV)</button>
      <button onclick="aesDecrypt()">è§£å¯†</button>
      <div id="aesResult" class="result" style="display: none;"></div>
    </div>

    <!-- RSA åŠ å¯† -->
    <div class="section">
      <h2>2. RSA åŠ å¯† (éå°ç¨±åŠ å¯†)</h2>
      <div class="input-group">
        <label>æ˜æ–‡:</label>
        <input type="text" id="rsaPlainText" value="RSA æ¸¬è©¦è¨Šæ¯" placeholder="è¼¸å…¥è¦åŠ å¯†çš„æ–‡å­—">
      </div>
      <button onclick="rsaGenerateKeys()">ç”¢ç”Ÿé‡‘é‘°å°</button>
      <button onclick="rsaEncrypt()">åŠ å¯†</button>
      <button onclick="rsaDecrypt()">è§£å¯†</button>
      <div id="rsaResult" class="result" style="display: none;"></div>
    </div>

    <!-- SHA å“ˆå¸Œ -->
    <div class="section">
      <h2>3. SHA å“ˆå¸Œ</h2>
      <div class="input-group">
        <label>è¦å“ˆå¸Œçš„æ–‡å­—:</label>
        <input type="text" id="hashText" value="Hello World" placeholder="è¼¸å…¥è¦å“ˆå¸Œçš„æ–‡å­—">
      </div>
      <button onclick="sha256Hash()">SHA-256</button>
      <button onclick="sha512Hash()">SHA-512</button>
      <div id="hashResult" class="result" style="display: none;"></div>
    </div>

    <!-- KDF å¯†é‘°æ´¾ç”Ÿ -->
    <div class="section">
      <h2>4. KDF å¯†é‘°æ´¾ç”Ÿ</h2>
      <div class="input-group">
        <label>å¯†ç¢¼:</label>
        <input type="password" id="kdfPassword" value="myPassword123" placeholder="è¼¸å…¥å¯†ç¢¼">
      </div>
      <button onclick="kdfGenerate()">ç”¢ç”Ÿéš¨æ©Ÿé¹½</button>
      <button onclick="kdfDerive()">æ´¾ç”Ÿå¯†é‘° (Argon2)</button>
      <button onclick="kdfDerivePbkdf2()">æ´¾ç”Ÿå¯†é‘° (PBKDF2)</button>
      <button onclick="kdfVerify()">é©—è­‰å¯†é‘°</button>
      <div id="kdfResult" class="result" style="display: none;"></div>
    </div>

    <!-- å®Œæ•´ç¯„ä¾‹ -->
    <div class="section">
      <h2>5. å®Œæ•´ç¯„ä¾‹: å¯†ç¢¼åŠ å¯†ç³»çµ±</h2>
      <div class="grid">
        <div>
          <h3 style="color: #667eea; margin-bottom: 10px;">åŠ å¯†</h3>
          <div class="input-group">
            <label>æ˜æ–‡:</label>
            <textarea id="fullPlainText" placeholder="è¼¸å…¥è¦åŠ å¯†çš„æ–‡å­—">é€™æ˜¯æ©Ÿå¯†è³‡æ–™ï¼Œéœ€è¦ç”¨å¯†ç¢¼ä¿è­·</textarea>
          </div>
          <div class="input-group">
            <label>å¯†ç¢¼:</label>
            <input type="password" id="fullPassword" value="mySecurePassword" placeholder="è¼¸å…¥å¯†ç¢¼">
          </div>
          <button onclick="fullEncrypt()">åŠ å¯†</button>
        </div>
        <div>
          <h3 style="color: #667eea; margin-bottom: 10px;">è§£å¯†</h3>
          <div class="input-group">
            <label>å¯†ç¢¼:</label>
            <input type="password" id="fullDecryptPassword" value="mySecurePassword" placeholder="è¼¸å…¥å¯†ç¢¼">
          </div>
          <button onclick="fullDecrypt()">è§£å¯†</button>
        </div>
      </div>
      <div id="fullResult" class="result" style="display: none;"></div>
    </div>
  </div>

  <script type="module">
    import { CryptoInitializer, Pbkdf2Strategy } from './src/index.js';
    
    // å…¨åŸŸè®Šæ•¸å„²å­˜çµæœ
    window.cryptoData = {
      aes: {},
      rsa: {},
      kdf: {},
      full: {}
    };

    // ==================== AES åŠŸèƒ½ ====================
    window.aesEncryptFixed = async function() {
      try {
        const plainText = document.getElementById('aesPlainText').value;
        const key = document.getElementById('aesKey').value;
        const iv = 'fixedIV12345678';
        
        await CryptoInitializer.initAesSetting(key, iv);
        const context = CryptoInitializer.getAesContextForEncrypt();
        const result = await context.encryptToBase64(plainText);
        
        if (result.success) {
          window.cryptoData.aes.cipher = result.data;
          window.cryptoData.aes.iv = iv;
          window.cryptoData.aes.key = key;
          showResult('aesResult', `åŠ å¯†æˆåŠŸ!<br><strong>å¯†æ–‡:</strong> ${result.data}`, 'success');
        }
      } catch (error) {
        showResult('aesResult', `åŠ å¯†å¤±æ•—: ${error.message}`, 'error');
      }
    };

    window.aesEncryptRandom = async function() {
      try {
        const plainText = document.getElementById('aesPlainText').value;
        const key = document.getElementById('aesKey').value;
        
        await CryptoInitializer.initAesSetting(key);
        const context = CryptoInitializer.getAesContextForEncryptByRandomIV();
        const result = await context.encryptWithIVToBase64(plainText);
        
        if (result.success) {
          window.cryptoData.aes.cipher = result.cipherText;
          window.cryptoData.aes.iv = result.iv;
          window.cryptoData.aes.key = key;
          showResult('aesResult', `åŠ å¯†æˆåŠŸ!<br><strong>å¯†æ–‡:</strong> ${result.cipherText}<br><strong>IV:</strong> ${result.iv}`, 'success');
        }
      } catch (error) {
        showResult('aesResult', `åŠ å¯†å¤±æ•—: ${error.message}`, 'error');
      }
    };

    window.aesDecrypt = async function() {
      try {
        if (!window.cryptoData.aes.cipher) {
          throw new Error('è«‹å…ˆåŠ å¯†!');
        }
        
        const context = CryptoInitializer.getAesContextForDecryptByRandomIV(window.cryptoData.aes.iv);
        const result = await context.decryptFromBase64(window.cryptoData.aes.cipher);
        
        if (result.success) {
          showResult('aesResult', `è§£å¯†æˆåŠŸ!<br><strong>æ˜æ–‡:</strong> ${result.data}`, 'success');
        }
      } catch (error) {
        showResult('aesResult', `è§£å¯†å¤±æ•—: ${error.message}`, 'error');
      }
    };

    // ==================== RSA åŠŸèƒ½ ====================
    window.rsaGenerateKeys = async function() {
      try {
        const keys = await CryptoInitializer.rsaGenerateKeys(2048);
        window.cryptoData.rsa.publicKey = keys.publicKey;
        window.cryptoData.rsa.privateKey = keys.privateKey;
        await CryptoInitializer.initRsaSetting(keys.publicKey, keys.privateKey);
        showResult('rsaResult', `é‡‘é‘°å°ç”¢ç”ŸæˆåŠŸ!<br><strong>å…¬é‘°:</strong> ${keys.publicKey.substring(0, 100)}...<br><strong>ç§é‘°:</strong> ${keys.privateKey.substring(0, 100)}...`, 'success');
      } catch (error) {
        showResult('rsaResult', `ç”¢ç”Ÿé‡‘é‘°å¤±æ•—: ${error.message}`, 'error');
      }
    };

    window.rsaEncrypt = async function() {
      try {
        if (!window.cryptoData.rsa.publicKey) {
          throw new Error('è«‹å…ˆç”¢ç”Ÿé‡‘é‘°å°!');
        }
        
        const plainText = document.getElementById('rsaPlainText').value;
        const context = CryptoInitializer.getRsaContext();
        const result = await context.encryptToBase64(plainText);
        
        if (result.success) {
          window.cryptoData.rsa.cipher = result.data;
          showResult('rsaResult', `åŠ å¯†æˆåŠŸ!<br><strong>å¯†æ–‡:</strong> ${result.data}`, 'success');
        }
      } catch (error) {
        showResult('rsaResult', `åŠ å¯†å¤±æ•—: ${error.message}`, 'error');
      }
    };

    window.rsaDecrypt = async function() {
      try {
        if (!window.cryptoData.rsa.cipher) {
          throw new Error('è«‹å…ˆåŠ å¯†!');
        }
        
        const context = CryptoInitializer.getRsaContext();
        const result = await context.decryptFromBase64(window.cryptoData.rsa.cipher);
        
        if (result.success) {
          showResult('rsaResult', `è§£å¯†æˆåŠŸ!<br><strong>æ˜æ–‡:</strong> ${result.data}`, 'success');
        }
      } catch (error) {
        showResult('rsaResult', `è§£å¯†å¤±æ•—: ${error.message}`, 'error');
      }
    };

    // ==================== SHA å“ˆå¸Œ ====================
    window.sha256Hash = async function() {
      try {
        const text = document.getElementById('hashText').value;
        const context = CryptoInitializer.getSha256HashContext();
        const result = await context.encryptToBase64(text);
        
        if (result.success) {
          showResult('hashResult', `SHA-256 å“ˆå¸Œ:<br><strong>${result.data}</strong>`, 'success');
        }
      } catch (error) {
        showResult('hashResult', `å“ˆå¸Œå¤±æ•—: ${error.message}`, 'error');
      }
    };

    window.sha512Hash = async function() {
      try {
        const text = document.getElementById('hashText').value;
        const context = CryptoInitializer.getSha512HashContext();
        const result = await context.encryptToBase64(text);
        
        if (result.success) {
          showResult('hashResult', `SHA-512 å“ˆå¸Œ:<br><strong>${result.data}</strong>`, 'success');
        }
      } catch (error) {
        showResult('hashResult', `å“ˆå¸Œå¤±æ•—: ${error.message}`, 'error');
      }
    };

    // ==================== KDF åŠŸèƒ½ ====================
    window.kdfGenerate = function() {
      try {
        const { base64Salt, bytesSalt } = CryptoInitializer.generateSalt(16);
        window.cryptoData.kdf.salt = bytesSalt;
        window.cryptoData.kdf.saltBase64 = base64Salt;
        showResult('kdfResult', `éš¨æ©Ÿé¹½ç”¢ç”ŸæˆåŠŸ!<br><strong>Base64:</strong> ${base64Salt}`, 'success');
      } catch (error) {
        showResult('kdfResult', `ç”¢ç”Ÿé¹½å¤±æ•—: ${error.message}`, 'error');
      }
    };

    window.kdfDerive = async function() {
      try {
        if (!window.cryptoData.kdf.salt) {
          throw new Error('è«‹å…ˆç”¢ç”Ÿéš¨æ©Ÿé¹½!');
        }
        
        const password = document.getElementById('kdfPassword').value;
        
        // å‹•æ…‹è¼‰å…¥ Argon2Strategy
        showResult('kdfResult', 'æ­£åœ¨ä½¿ç”¨ Argon2 æ´¾ç”Ÿå¯†é‘°ï¼Œè«‹ç¨å€™...', 'success');
        
        const { Argon2Strategy } = await import('./src/kdf/Argon2Strategy.js');
        const argon2Strategy = new Argon2Strategy(65536, 1);
        
        const derivedKey = await CryptoInitializer.deriveKeyFromPasswordToBase64(
          password,
          window.cryptoData.kdf.salt,
          argon2Strategy,
          3,
          32
        );
        
        window.cryptoData.kdf.derivedKey = derivedKey;
        showResult('kdfResult', `Argon2 æ´¾ç”ŸæˆåŠŸ!<br><strong>å¯†é‘°:</strong> ${derivedKey}`, 'success');
      } catch (error) {
        showResult('kdfResult', `æ´¾ç”Ÿå¤±æ•—: ${error.message}`, 'error');
      }
    };

    window.kdfDerivePbkdf2 = async function() {
      try {
        if (!window.cryptoData.kdf.salt) {
          throw new Error('è«‹å…ˆç”¢ç”Ÿéš¨æ©Ÿé¹½!');
        }
        
        const password = document.getElementById('kdfPassword').value;
        const pbkdf2Strategy = new Pbkdf2Strategy();
        const derivedKey = await CryptoInitializer.deriveKeyFromPasswordToBase64(
          password,
          window.cryptoData.kdf.salt,
          pbkdf2Strategy,
          100000,
          32
        );
        
        window.cryptoData.kdf.derivedKeyPbkdf2 = derivedKey;
        showResult('kdfResult', `PBKDF2 æ´¾ç”ŸæˆåŠŸ!<br><strong>å¯†é‘°:</strong> ${derivedKey}`, 'success');
      } catch (error) {
        showResult('kdfResult', `æ´¾ç”Ÿå¤±æ•—: ${error.message}`, 'error');
      }
    };

    window.kdfVerify = async function() {
      try {
        if (!window.cryptoData.kdf.derivedKeyPbkdf2) {
          throw new Error('è«‹å…ˆä½¿ç”¨ PBKDF2 æ´¾ç”Ÿå¯†é‘°!');
        }
        
        const password = document.getElementById('kdfPassword').value;
        const keyBytes = atob(window.cryptoData.kdf.derivedKeyPbkdf2).split('').map(c => c.charCodeAt(0));
        const expectedKey = new Uint8Array(keyBytes);
        
        const pbkdf2Strategy = new Pbkdf2Strategy();
        const isValid = await CryptoInitializer.verifyDerivedKey(
          password,
          window.cryptoData.kdf.salt,
          expectedKey,
          pbkdf2Strategy,
          100000
        );
        
        showResult('kdfResult', `é©—è­‰çµæœ: <strong>${isValid ? 'æˆåŠŸ âœ“' : 'å¤±æ•— âœ—'}</strong>`, isValid ? 'success' : 'error');
      } catch (error) {
        showResult('kdfResult', `é©—è­‰å¤±æ•—: ${error.message}`, 'error');
      }
    };

    // ==================== å®Œæ•´ç¯„ä¾‹ ====================
    window.fullEncrypt = async function() {
      try {
        const plainText = document.getElementById('fullPlainText').value;
        const password = document.getElementById('fullPassword').value;
        
        showResult('fullResult', 'æ­£åœ¨åŠ å¯†ï¼Œè«‹ç¨å€™...', 'success');
        
        // 1. ç”¢ç”Ÿéš¨æ©Ÿé¹½
        const { base64Salt, bytesSalt } = CryptoInitializer.generateSalt(16);
        
        // 2. å¾å¯†ç¢¼æ´¾ç”Ÿå¯†é‘° (ä½¿ç”¨ PBKDF2 è¼ƒå¿«)
        const pbkdf2 = new Pbkdf2Strategy();
        const derivedKey = await CryptoInitializer.deriveKeyFromPassword(password, bytesSalt, pbkdf2, 100000, 32);
        
        // 3. ä½¿ç”¨æ´¾ç”Ÿçš„å¯†é‘°é€²è¡Œ AES åŠ å¯†
        const aesContext = CryptoInitializer.getAesContextForEncryptByRandomIV();
        aesContext.key = derivedKey;
        
        const encryptResult = await aesContext.encryptWithIVToBase64(plainText);
        
        if (encryptResult.success) {
          window.cryptoData.full = {
            cipherText: encryptResult.cipherText,
            iv: encryptResult.iv,
            salt: base64Salt
          };
          
          showResult('fullResult', 
            `åŠ å¯†æˆåŠŸ!<br>` +
            `<strong>å¯†æ–‡:</strong> ${encryptResult.cipherText}<br>` +
            `<strong>IV:</strong> ${encryptResult.iv}<br>` +
            `<strong>é¹½:</strong> ${base64Salt}`,
            'success'
          );
        }
      } catch (error) {
        showResult('fullResult', `åŠ å¯†å¤±æ•—: ${error.message}`, 'error');
      }
    };

    window.fullDecrypt = async function() {
      try {
        if (!window.cryptoData.full.cipherText) {
          throw new Error('è«‹å…ˆåŠ å¯†!');
        }
        
        const password = document.getElementById('fullDecryptPassword').value;
        
        showResult('fullResult', 'æ­£åœ¨è§£å¯†ï¼Œè«‹ç¨å€™...', 'success');
        
        // 1. å¾ Base64 è½‰æ›é¹½
        const saltBinary = atob(window.cryptoData.full.salt);
        const bytesSalt = new Uint8Array(saltBinary.length);
        for (let i = 0; i < saltBinary.length; i++) {
          bytesSalt[i] = saltBinary.charCodeAt(i);
        }
        
        // 2. å¾å¯†ç¢¼æ´¾ç”Ÿç›¸åŒçš„å¯†é‘° (ä½¿ç”¨ PBKDF2 è¼ƒå¿«)
        const pbkdf2 = new Pbkdf2Strategy();
        const derivedKey = await CryptoInitializer.deriveKeyFromPassword(password, bytesSalt, pbkdf2, 100000, 32);
        
        // 3. ä½¿ç”¨æ´¾ç”Ÿçš„å¯†é‘°é€²è¡Œ AES è§£å¯†
        const aesContext = CryptoInitializer.getAesContextForDecryptByRandomIV(window.cryptoData.full.iv);
        aesContext.key = derivedKey;
        
        const decryptResult = await aesContext.decryptFromBase64(window.cryptoData.full.cipherText);
        
        if (decryptResult.success) {
          showResult('fullResult', `è§£å¯†æˆåŠŸ!<br><strong>æ˜æ–‡:</strong> ${decryptResult.data}`, 'success');
        } else {
          showResult('fullResult', `è§£å¯†å¤±æ•— (å¯èƒ½å¯†ç¢¼éŒ¯èª¤)`, 'error');
        }
      } catch (error) {
        showResult('fullResult', `è§£å¯†å¤±æ•—: ${error.message}`, 'error');
      }
    };

    // ==================== è¼”åŠ©å‡½æ•¸ ====================
    function showResult(elementId, message, type = '') {
      const element = document.getElementById(elementId);
      element.innerHTML = message;
      element.style.display = 'block';
      element.className = 'result ' + type;
    }

    // ==================== ç’°å¢ƒæª¢æŸ¥ ====================
    function checkEnvironment() {
      if (!window.crypto || !window.crypto.subtle) {
        alert('âš ï¸ æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´ Web Crypto APIï¼Œæˆ–éœ€è¦åœ¨ HTTPS/localhost ç’°å¢ƒä¸‹é‹è¡Œï¼');
        console.error('Web Crypto API ä¸å¯ç”¨');
        return false;
      }
      if (!window.TextEncoder || !window.TextDecoder) {
        alert('âš ï¸ æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´ TextEncoder/TextDecoderï¼');
        console.error('TextEncoder/TextDecoder ä¸å¯ç”¨');
        return false;
      }
      console.log('âœ… ç’°å¢ƒæª¢æŸ¥é€šé');
      return true;
    }

    // é é¢è¼‰å…¥å®Œæˆæç¤º
    if (checkEnvironment()) {
      console.log('âœ… Crypto JS Library å·²è¼‰å…¥!');
      console.log('ğŸ’¡ é–‹å•Ÿé–‹ç™¼è€…å·¥å…·æŸ¥çœ‹åŠ å¯†éç¨‹');
    }
  </script>
</body>
</html>
