<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>è‡ªå‹•æ¸¬è©¦æ‰€æœ‰åŠŸèƒ½</title>
  <script type="importmap">
    {
      "imports": {}
    }
  </script>
  <style>
    body {
      font-family: 'Courier New', monospace;
      max-width: 900px;
      margin: 20px auto;
      padding: 20px;
      background: #1e1e1e;
      color: #d4d4d4;
    }
    h1 {
      color: #4ec9b0;
      border-bottom: 2px solid #4ec9b0;
      padding-bottom: 10px;
    }
    .test-result {
      margin: 10px 0;
      padding: 10px;
      border-left: 4px solid #ccc;
      background: #2d2d2d;
      font-size: 14px;
    }
    .test-result.success {
      border-left-color: #4ec9b0;
    }
    .test-result.error {
      border-left-color: #f48771;
      color: #f48771;
    }
    .test-result.running {
      border-left-color: #dcdcaa;
      color: #dcdcaa;
    }
    button {
      background: #0e639c;
      color: white;
      border: none;
      padding: 12px 24px;
      font-size: 16px;
      cursor: pointer;
      border-radius: 4px;
      margin: 10px 0;
    }
    button:hover {
      background: #1177bb;
    }
    button:disabled {
      background: #666;
      cursor: not-allowed;
    }
    .summary {
      margin-top: 20px;
      padding: 15px;
      background: #2d2d2d;
      border-radius: 4px;
    }
    .summary h2 {
      color: #4ec9b0;
      margin-top: 0;
    }
    pre {
      background: #1e1e1e;
      padding: 10px;
      border-radius: 4px;
      overflow-x: auto;
      font-size: 12px;
    }
  </style>
</head>
<body>
  <h1>ğŸ§ª Crypto Library - è‡ªå‹•åŒ–æ¸¬è©¦å¥—ä»¶</h1>
  
  <button id="runAllBtn" onclick="runAllTests()">â–¶ï¸ åŸ·è¡Œæ‰€æœ‰æ¸¬è©¦</button>
  <button onclick="clearResults()">ğŸ—‘ï¸ æ¸…é™¤çµæœ</button>
  
  <div id="results"></div>
  
  <div id="summary" class="summary" style="display: none;">
    <h2>ğŸ“Š æ¸¬è©¦æ‘˜è¦</h2>
    <div id="summaryContent"></div>
  </div>

  <script type="module">
    import { CryptoInitializer, Pbkdf2Strategy } from './src/index.js';
    import { 
      encryptAes, 
      decryptAes, 
      encryptAesByRandomIV, 
      decryptAesByRandomIV 
    } from './src/CryptoExtension.js';
    
    let testResults = [];
    
    function addResult(name, status, message, details = '') {
      const result = { name, status, message, details };
      testResults.push(result);
      
      const resultsDiv = document.getElementById('results');
      const div = document.createElement('div');
      div.className = `test-result ${status}`;
      div.id = `test-${name}`;
      
      let icon = status === 'success' ? 'âœ…' : status === 'error' ? 'âŒ' : 'â³';
      div.innerHTML = `
        <strong>${icon} ${name}</strong><br>
        ${message}
        ${details ? `<pre>${details}</pre>` : ''}
      `;
      
      resultsDiv.appendChild(div);
      div.scrollIntoView({ behavior: 'smooth', block: 'end' });
    }
    
    function updateResult(name, status, message, details = '') {
      const testId = `test-${name}`;
      const existingDiv = document.getElementById(testId);
      
      if (existingDiv) {
        existingDiv.remove();
      }
      
      // æ›´æ–°çµæœé™£åˆ—
      testResults = testResults.filter(r => r.name !== name);
      addResult(name, status, message, details);
    }
    
    function updateSummary() {
      const success = testResults.filter(r => r.status === 'success').length;
      const error = testResults.filter(r => r.status === 'error').length;
      const total = testResults.length;
      
      const summaryDiv = document.getElementById('summary');
      const contentDiv = document.getElementById('summaryContent');
      
      summaryDiv.style.display = 'block';
      contentDiv.innerHTML = `
        <p><strong>ç¸½æ¸¬è©¦æ•¸:</strong> ${total}</p>
        <p><strong>âœ… æˆåŠŸ:</strong> ${success}</p>
        <p><strong>âŒ å¤±æ•—:</strong> ${error}</p>
        <p><strong>æˆåŠŸç‡:</strong> ${total > 0 ? ((success/total)*100).toFixed(1) : 0}%</p>
      `;
    }
    
    window.runAllTests = async function() {
      const btn = document.getElementById('runAllBtn');
      btn.disabled = true;
      btn.textContent = 'â³ æ¸¬è©¦åŸ·è¡Œä¸­...';
      
      testResults = [];
      document.getElementById('results').innerHTML = '';
      document.getElementById('summary').style.display = 'none';
      
      // ç’°å¢ƒæª¢æŸ¥ï¼ˆä¸è¨ˆå…¥æ¸¬è©¦æ•¸é‡ï¼‰
      try {
        if (!window.crypto || !window.crypto.subtle) {
          throw new Error('Web Crypto API ä¸å¯ç”¨');
        }
        if (!window.TextEncoder) {
          throw new Error('TextEncoder ä¸å¯ç”¨');
        }
      } catch (error) {
        // é¡¯ç¤ºéŒ¯èª¤ä½†ä¸è¨ˆå…¥æ¸¬è©¦
        document.getElementById('results').innerHTML = `<div class="error"><h3>âŒ ç’°å¢ƒæª¢æŸ¥å¤±æ•—</h3><p>${error.message}</p></div>`;
        btn.disabled = false;
        btn.textContent = 'â–¶ï¸ åŸ·è¡Œæ‰€æœ‰æ¸¬è©¦';
        return;
      }
      
      // æ¸¬è©¦ 1: AES åŠ å¯† (CryptoInitializer)
      try {
        addResult('æ¸¬è©¦ 1: AES åŠ å¯†', 'running', 'æ¸¬è©¦ä¸­...');
        await new Promise(resolve => setTimeout(resolve, 100));
        
        const plainText = 'Hello, World! æ¸¬è©¦è¨Šæ¯ ğŸ”';
        const key = 'mySecretKey123';
        
        await CryptoInitializer.initAesSetting(key);
        const ctx = CryptoInitializer.getAesContextForEncryptByRandomIV();
        const encResult = await ctx.encryptWithIVToBase64(plainText);
        
        if (!encResult.success) throw new Error('åŠ å¯†å¤±æ•—');
        
        const decCtx = CryptoInitializer.getAesContextForDecryptByRandomIV(encResult.iv);
        const decResult = await decCtx.decryptFromBase64(encResult.cipherText);
        
        if (!decResult.success) throw new Error('è§£å¯†å¤±æ•—');
        if (decResult.data !== plainText) throw new Error('è§£å¯†çµæœä¸ç¬¦');
        
        updateResult('æ¸¬è©¦ 1: AES åŠ å¯†', 'success', 'åŠ å¯†/è§£å¯†æˆåŠŸ', 
          `åŸæ–‡: ${plainText}\nå¯†æ–‡: ${encResult.cipherText.substring(0, 40)}...\nè§£å¯†: ${decResult.data}`);
      } catch (error) {
        updateResult('æ¸¬è©¦ 1: AES åŠ å¯†', 'error', error.message);
      }
      
      // æ¸¬è©¦ 2: CryptoExtension
      try {
        addResult('æ¸¬è©¦ 2: CryptoExtension', 'running', 'æ¸¬è©¦ä¸­...');
        await new Promise(resolve => setTimeout(resolve, 100));
        
        const plainText = 'Extension Test';
        const { cipher, iv } = await encryptAesByRandomIV(plainText);
        const decrypted = await decryptAesByRandomIV(cipher, iv);
        
        if (decrypted !== plainText) throw new Error('è§£å¯†çµæœä¸ç¬¦');
        
        updateResult('æ¸¬è©¦ 2: CryptoExtension', 'success', 'Extension Methods æ­£å¸¸é‹ä½œ');
      } catch (error) {
        updateResult('æ¸¬è©¦ 2: CryptoExtension', 'error', error.message);
      }
      
      // æ¸¬è©¦ 3: RSA åŠ å¯†
      try {
        addResult('æ¸¬è©¦ 3: RSA åŠ å¯†', 'running', 'ç”¢ç”Ÿå¯†é‘°ä¸­...');
        await new Promise(resolve => setTimeout(resolve, 100));
        
        const plainText = 'RSA Test Message';
        const keys = await CryptoInitializer.rsaGenerateKeys(2048);
        await CryptoInitializer.initRsaSetting(keys.publicKey, keys.privateKey);
        
        const ctx = CryptoInitializer.getRsaContext();
        const encResult = await ctx.encryptToBase64(plainText);
        
        if (!encResult.success) throw new Error('åŠ å¯†å¤±æ•—');
        
        const decResult = await ctx.decryptFromBase64(encResult.data);
        
        if (!decResult.success) throw new Error('è§£å¯†å¤±æ•—');
        if (decResult.data !== plainText) throw new Error('è§£å¯†çµæœä¸ç¬¦');
        
        updateResult('æ¸¬è©¦ 3: RSA åŠ å¯†', 'success', 'RSA-2048 åŠ å¯†/è§£å¯†æˆåŠŸ');
      } catch (error) {
        updateResult('æ¸¬è©¦ 3: RSA åŠ å¯†', 'error', error.message);
      }
      
      // æ¸¬è©¦ 4: SHA-256
      try {
        addResult('æ¸¬è©¦ 4: SHA-256', 'running', 'æ¸¬è©¦ä¸­...');
        await new Promise(resolve => setTimeout(resolve, 100));
        
        const text = 'Hello World';
        const ctx = CryptoInitializer.getSha256HashContext();
        const result = await ctx.encryptToBase64(text);
        
        if (!result.success) throw new Error('å“ˆå¸Œå¤±æ•—');
        
        // é©—è­‰å“ˆå¸Œå€¼æ˜¯å¦ä¸€è‡´
        const ctx2 = CryptoInitializer.getSha256HashContext();
        const result2 = await ctx2.encryptToBase64(text);
        
        if (result.data !== result2.data) throw new Error('å“ˆå¸Œçµæœä¸ä¸€è‡´');
        
        updateResult('æ¸¬è©¦ 4: SHA-256', 'success', 'å“ˆå¸Œè¨ˆç®—æ­£ç¢º', 
          `è¼¸å…¥: ${text}\nSHA-256: ${result.data}`);
      } catch (error) {
        updateResult('æ¸¬è©¦ 4: SHA-256', 'error', error.message);
      }
      
      // æ¸¬è©¦ 5: SHA-512
      try {
        addResult('æ¸¬è©¦ 5: SHA-512', 'running', 'æ¸¬è©¦ä¸­...');
        await new Promise(resolve => setTimeout(resolve, 100));
        
        const text = 'Hello World';
        const ctx = CryptoInitializer.getSha512HashContext();
        const result = await ctx.encryptToBase64(text);
        
        if (!result.success) throw new Error('å“ˆå¸Œå¤±æ•—');
        if (result.data.length < 80) throw new Error('SHA-512 å“ˆå¸Œé•·åº¦ä¸æ­£ç¢º');
        
        updateResult('æ¸¬è©¦ 5: SHA-512', 'success', 'SHA-512 å“ˆå¸Œè¨ˆç®—æ­£ç¢º');
      } catch (error) {
        updateResult('æ¸¬è©¦ 5: SHA-512', 'error', error.message);
      }
      
      // æ¸¬è©¦ 6: PBKDF2
      try {
        addResult('æ¸¬è©¦ 6: PBKDF2', 'running', 'æ´¾ç”Ÿå¯†é‘°ä¸­...');
        await new Promise(resolve => setTimeout(resolve, 100));
        
        const password = 'myPassword123';
        const { bytesSalt } = CryptoInitializer.generateSalt(16);
        const pbkdf2 = new Pbkdf2Strategy();
        
        const key1 = await CryptoInitializer.deriveKeyFromPasswordToBase64(
          password, bytesSalt, pbkdf2, 1000, 32
        );
        
        const key2 = await CryptoInitializer.deriveKeyFromPasswordToBase64(
          password, bytesSalt, pbkdf2, 1000, 32
        );
        
        if (key1 !== key2) throw new Error('ç›¸åŒå¯†ç¢¼å’Œé¹½æ‡‰ç”¢ç”Ÿç›¸åŒå¯†é‘°');
        
        updateResult('æ¸¬è©¦ 6: PBKDF2', 'success', 'PBKDF2 å¯†é‘°æ´¾ç”Ÿæ­£ç¢º');
      } catch (error) {
        updateResult('æ¸¬è©¦ 6: PBKDF2', 'error', error.message);
      }
      
      // æ¸¬è©¦ 7: å®Œæ•´åŠ å¯†æµç¨‹
      try {
        addResult('æ¸¬è©¦ 7: å®Œæ•´æµç¨‹', 'running', 'æ¸¬è©¦å¯†ç¢¼åŠ å¯†ç³»çµ±...');
        await new Promise(resolve => setTimeout(resolve, 100));
        
        const plainText = 'é€™æ˜¯éœ€è¦ä¿è­·çš„æ©Ÿå¯†è³‡æ–™ ğŸ”’';
        const password = 'securePassword123';
        
        // åŠ å¯†
        const { base64Salt, bytesSalt } = CryptoInitializer.generateSalt(16);
        const pbkdf2 = new Pbkdf2Strategy();
        const derivedKey = await CryptoInitializer.deriveKeyFromPassword(
          password, bytesSalt, pbkdf2, 10000, 32
        );
        
        const aesCtx = CryptoInitializer.getAesContextForEncryptByRandomIV();
        aesCtx.key = derivedKey;
        const encResult = await aesCtx.encryptWithIVToBase64(plainText);
        
        if (!encResult.success) throw new Error('åŠ å¯†å¤±æ•—');
        
        // è§£å¯†
        const saltBytes = new Uint8Array(
          atob(base64Salt).split('').map(c => c.charCodeAt(0))
        );
        const derivedKey2 = await CryptoInitializer.deriveKeyFromPassword(
          password, saltBytes, pbkdf2, 10000, 32
        );
        
        const decCtx = CryptoInitializer.getAesContextForDecryptByRandomIV(encResult.iv);
        decCtx.key = derivedKey2;
        const decResult = await decCtx.decryptFromBase64(encResult.cipherText);
        
        if (!decResult.success) throw new Error('è§£å¯†å¤±æ•—');
        if (decResult.data !== plainText) throw new Error('è§£å¯†çµæœä¸ç¬¦');
        
        updateResult('æ¸¬è©¦ 7: å®Œæ•´æµç¨‹', 'success', 
          'å¯†ç¢¼åŠ å¯†ç³»çµ±å®Œæ•´é‹ä½œ (KDF + AES)');
      } catch (error) {
        updateResult('æ¸¬è©¦ 7: å®Œæ•´æµç¨‹', 'error', error.message);
      }
      
      btn.disabled = false;
      btn.textContent = 'â–¶ï¸ åŸ·è¡Œæ‰€æœ‰æ¸¬è©¦';
      updateSummary();
    };
    
    window.clearResults = function() {
      document.getElementById('results').innerHTML = '';
      document.getElementById('summary').style.display = 'none';
      testResults = [];
    };
    
    // é é¢è¼‰å…¥æ™‚é¡¯ç¤ºç’°å¢ƒè³‡è¨Š
    console.log('ğŸ§ª è‡ªå‹•åŒ–æ¸¬è©¦å¥—ä»¶å·²è¼‰å…¥');
    console.log('ç’°å¢ƒè³‡è¨Š:');
    console.log('- Web Crypto API:', !!window.crypto?.subtle);
    console.log('- TextEncoder:', !!window.TextEncoder);
    console.log('- å”è­°:', window.location.protocol);
    console.log('- ä¸»æ©Ÿ:', window.location.host);
  </script>
</body>
</html>
